(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{244:function(_,v,e){"use strict";e.r(v);var t=e(0),a=Object(t.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",{attrs:{id:"python"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#python"}},[_._v("#")]),_._v(" Python")]),_._v(" "),e("p",[_._v("[TOC]")]),_._v(" "),e("h2",{attrs:{id:"变量与数据类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#变量与数据类型"}},[_._v("#")]),_._v(" 变量与数据类型")]),_._v(" "),e("ul",[e("li",[e("strong",[_._v("Python 属于强 · 动态类型的语言")])]),_._v(" "),e("li",[_._v("Number 数字类型\nInt 整数类型\nFloat 浮点数类型")]),_._v(" "),e("li",[_._v("Bool 布尔数类型")]),_._v(" "),e("li",[_._v("String 字符串类型（字符串切片语法）")]),_._v(" "),e("li",[_._v("List 列表：一组可重复元素组成的有序列表\ntuple(list) 方法将列表转换为元组")]),_._v(" "),e("li",[_._v("Tuple 元组（相当于自读列表）\nlist(typle) 方法将元组转换为列表")]),_._v(" "),e("li",[_._v("Dictionary 字典：一组键值对组成的无序列表，其中键唯一")])]),_._v(" "),e("h2",{attrs:{id:"控制流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#控制流"}},[_._v("#")]),_._v(" 控制流")]),_._v(" "),e("h3",{attrs:{id:"判断"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#判断"}},[_._v("#")]),_._v(" 判断")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("if / else")])]),_._v(" "),e("li",[e("code",[_._v("if / elif")])]),_._v(" "),e("li",[_._v("身份运算符\n使用 "),e("code",[_._v("is")]),_._v("、"),e("code",[_._v("not is")]),_._v(" 来比较数据的内存地址是否一致")])]),_._v(" "),e("h3",{attrs:{id:"循环"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#循环"}},[_._v("#")]),_._v(" 循环")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("while")])]),_._v(" "),e("li",[e("code",[_._v("for / in")]),_._v(" 遍历 list.value 或 map.key")]),_._v(" "),e("li",[e("code",[_._v("while / else")]),_._v(" 和 "),e("code",[_._v("for / else")])])]),_._v(" "),e("h2",{attrs:{id:"运算符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#运算符"}},[_._v("#")]),_._v(" 运算符")]),_._v(" "),e("ul",[e("li",[_._v("算数运算符\n幂运算：2**2")]),_._v(" "),e("li",[_._v("赋值运算符")]),_._v(" "),e("li",[_._v("比较运算符")]),_._v(" "),e("li",[_._v("逻辑运算符")])]),_._v(" "),e("h2",{attrs:{id:"函数与模块与包管理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数与模块与包管理"}},[_._v("#")]),_._v(" 函数与模块与包管理")]),_._v(" "),e("h3",{attrs:{id:"函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数"}},[_._v("#")]),_._v(" 函数")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("def <Function>")]),_._v(" 语句声明函数")]),_._v(" "),e("li",[_._v("缺省参数与不定参数")]),_._v(" "),e("li",[_._v("参数的扩展运算符")]),_._v(" "),e("li",[_._v("函数递归")])]),_._v(" "),e("h3",{attrs:{id:"模块"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模块"}},[_._v("#")]),_._v(" 模块")]),_._v(" "),e("ul",[e("li",[e("p",[e("code",[_._v("import <Modul>")]),_._v(" 语句导入模块，可以通过 "),e("code",[_._v("<Modul>.<Function>")]),_._v(" 的方式调用方法")])]),_._v(" "),e("li",[e("p",[e("code",[_._v("import <Modul> as <ModulName>")]),_._v(" 语句指定模块别名，应符合大驼峰命名法")])]),_._v(" "),e("li",[e("p",[e("code",[_._v("from <Modul> import <Function>")]),_._v(" 语句导入模块下对应的方法，不需要通过模块名就能调用\n这种导入方式可能会产生函数名冲突，后者会覆盖前者")])]),_._v(" "),e("li",[e("p",[e("code",[_._v("from <Modul> import <Function> as <ModulName>")]),_._v(" 语句为导入的方法指定别名")])]),_._v(" "),e("li",[e("p",[e("code",[_._v("from <Modul> import *")]),_._v(" 语句导入模块，并且不需要通过模块名就能调用方法\n这种方式同样可能产生函数名冲突")])]),_._v(" "),e("li",[e("p",[_._v("Python 在导入模块时，会优先查询当前目录下的自定义模块，再搜索系统目录下的系统模块\n在开发时，应避免自定义模块与系统模块重名")])]),_._v(" "),e("li",[e("p",[e("code",[_._v("__name__")]),_._v(" 属性在程序执行时值为字符串 "),e("code",[_._v("__main__")]),_._v("，在被作为模块调用时值为模块名")])])]),_._v(" "),e("h3",{attrs:{id:"包（package）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#包（package）"}},[_._v("#")]),_._v(" 包（package）")]),_._v(" "),e("ul",[e("li",[_._v("包是一个包含多个模块的特殊目录，包名带 "),e("code",[_._v("_")]),_._v(" 后缀")]),_._v(" "),e("li",[_._v("目录里包含一个 "),e("code",[_._v("__init__.py")]),_._v(" 文件，用于指定对外界提供的模块列表\n语法 "),e("code",[_._v("from . import <Modul>")])]),_._v(" "),e("li",[_._v("导入包可以一次性导入包里的所有模块")]),_._v(" "),e("li",[_._v("制作包\n"),e("ol",[e("li",[_._v("在包目录的上级目录中建立并配置 setup.py 文件")]),_._v(" "),e("li",[_._v("在终端执行 "),e("code",[_._v("python setup.py build")]),_._v(" 命令构建模块")]),_._v(" "),e("li",[_._v("在终端执行 "),e("code",[_._v("python setup.py sdist")]),_._v(" 命令生成压缩包")])])]),_._v(" "),e("li",[_._v("安装包\n"),e("ol",[e("li",[_._v("加压压缩包")]),_._v(" "),e("li",[e("code",[_._v("python setup.py install")]),_._v(" 命令安装包到 Python 的系统目录")])])]),_._v(" "),e("li",[_._v("卸载包\n"),e("code",[_._v("rm -r <package>*")]),_._v(" 命令从 Python 的系统目录中删除包")]),_._v(" "),e("li",[_._v("包或模块的 "),e("code",[_._v("__file__")]),_._v(" 属性记录了其路径")]),_._v(" "),e("li",[_._v("使用 pip 安装第三方模块\n"),e("code",[_._v("pip install <Modul>")]),_._v(" "),e("code",[_._v("pip uninstall <Modul>")])])]),_._v(" "),e("h2",{attrs:{id:"面向对象（oop）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#面向对象（oop）"}},[_._v("#")]),_._v(" 面向对象（OOP）")]),_._v(" "),e("h3",{attrs:{id:"封装"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#封装"}},[_._v("#")]),_._v(" 封装")]),_._v(" "),e("ul",[e("li",[e("strong",[_._v("封装：将实现一类功能的属性与方法封装成一个抽象的类")]),_._v("\n对象可以将自身的属性和方法交给可信的类或对象操作，对不可信的隐藏")]),_._v(" "),e("li",[e("strong",[_._v("Python 通过 "),e("code",[_._v("class")]),_._v(" 语句声明类，类名一般遵循大驼峰命名法")])]),_._v(" "),e("li",[e("strong",[_._v("再使用赋值语句将类实例化为对象")]),_._v("（不需要 "),e("code",[_._v("new")]),_._v(" 语句）")]),_._v(" "),e("li",[e("strong",[_._v("在实例化对象的同时，会执行 "),e("code",[_._v("__init__")]),_._v(" 方法来初始化对象")]),_._v("（构造函数）")]),_._v(" "),e("li",[_._v("在销毁一个对象时，会先执行一次对象的 "),e("code",[_._v("__del__")]),_._v(" 方法（生命周期）")]),_._v(" "),e("li",[_._v("使用 "),e("code",[_._v("print")]),_._v(" 方法打印一个对象时，默认输出这个对象归属的类和内存地址（0x）\n使用 "),e("code",[_._v("__str__")]),_._v(" 方法可以自定义该对象的打印内容（需要 "),e("code",[_._v("return")]),_._v(" 一个字符串）")]),_._v(" "),e("li",[e("strong",[_._v('在对象的属性名或方法名前加上 "__" 前缀可以实现私有属性或私有方法')]),_._v("（伪）\n可以通过在属性名或方法名前面加上 "),e("code",[_._v("_<className>")]),_._v(" 的方式访问私有属性或私有方法")])]),_._v(" "),e("h3",{attrs:{id:"继承（派生）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#继承（派生）"}},[_._v("#")]),_._v(" 继承（派生）")]),_._v(" "),e("ul",[e("li",[e("strong",[_._v("继承（extend）：在不需要重写类的情况下，对原本的功能进行扩展")])]),_._v(" "),e("li",[_._v("使用 "),e("code",[_._v("class Child(Parent):")]),_._v(" 语法实现类的继承\n可以同时继承多个父类，实现多继承 "),e("code",[_._v("class Child(Parent1, Parent2...):")])]),_._v(" "),e("li",[_._v("子类无法继承父类的私有属性和私有方法，也不能调用父类的方法对子类的私有属性进行操作")]),_._v(" "),e("li",[_._v("Python 中，以 "),e("code",[_._v("object")]),_._v(" 类为基类的类为新式类，否则为旧式（经典）类；推荐使用新式类\n在 Python3 中如果没有指定父类，会默认使用 "),e("code",[_._v("object")]),_._v(" 类作为父类")])]),_._v(" "),e("h3",{attrs:{id:"多态"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多态"}},[_._v("#")]),_._v(" 多态")]),_._v(" "),e("ul",[e("li",[e("strong",[_._v("多态：在继承链的不同层次名称相同但是功能不同的函数")]),_._v("\n本质是允许子类重写（override）或扩展父类定义的方法，实现接口重用")]),_._v(" "),e("li",[e("strong",[_._v("扩展父类方法：使用 "),e("code",[_._v("super().function()")]),_._v(" 语法调用父类的方法")]),_._v("\n本质上是使用 "),e("code",[_._v("super")]),_._v(" 对象调用父类的方法")])]),_._v(" "),e("h3",{attrs:{id:"类属性与类方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类属性与类方法"}},[_._v("#")]),_._v(" 类属性与类方法")]),_._v(" "),e("ul",[e("li",[_._v("声明类方法时需要在上面添加一行 "),e("code",[_._v("@classmathod")]),_._v(" 修饰器来标识")]),_._v(" "),e("li",[_._v("类方法的第一个参数必须是 "),e("code",[_._v("cls")]),_._v("，而不是 "),e("code",[_._v("self")])]),_._v(" "),e("li",[_._v("封装类方式是为了便于访问类属性")])]),_._v(" "),e("h3",{attrs:{id:"静态方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#静态方法"}},[_._v("#")]),_._v(" 静态方法")]),_._v(" "),e("ul",[e("li",[_._v("声明静态方法时需要在上面添加一行 "),e("code",[_._v("@staticmathod")]),_._v(" 修饰器来标识")]),_._v(" "),e("li",[_._v("静态方法不需要 "),e("code",[_._v("self")]),_._v(" 参数")])]),_._v(" "),e("h2",{attrs:{id:"设计模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#设计模式"}},[_._v("#")]),_._v(" 设计模式")]),_._v(" "),e("h3",{attrs:{id:"单例模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#单例模式"}},[_._v("#")]),_._v(" 单例模式")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("__new__")]),_._v(" 方法是由 "),e("code",[_._v("object")]),_._v(" 基类提供的内置静态方法\n用于给对象分配内存空间，并返回对象的引用（self）\n注意：该方法时静态方法，调用时需要传入 "),e("code",[_._v("cls")]),_._v(" 参数")]),_._v(" "),e("li",[_._v("重写 "),e("code",[_._v("__new__")]),_._v(" 方法，在创建实例时检查是否已经存在实例\n如果存在：返回该实例")]),_._v(" "),e("li",[_._v("重写 "),e("code",[_._v("__init__")]),_._v(" 方法，在初始化实例时检查是否需要初始化")])]),_._v(" "),e("h2",{attrs:{id:"异常处理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#异常处理"}},[_._v("#")]),_._v(" 异常处理")]),_._v(" "),e("ul",[e("li",[_._v("抛出（raise）异常\n在程序执行出现异常时会停止执行并抛出异常")]),_._v(" "),e("li",[_._v("捕获异常\n使用 "),e("code",[_._v("try - except")]),_._v(" 语句可以将抛出的异常捕获，使程序得以继续执行\n"),e("code",[_._v("try")]),_._v(" 下包含尝试执行的代码，"),e("code",[_._v("except")]),_._v(" 下包含捕获到异常后执行的代码\n异常只会被离它最近的 "),e("code",[_._v("except")]),_._v(" 捕获一次")]),_._v(" "),e("li",[_._v("根据错误类型捕获异常（有条件的 "),e("code",[_._v("except")]),_._v(" 子句）\n"),e("code",[_._v("except <reason>:")])]),_._v(" "),e("li",[_._v("捕获未知错误，将异常信息作为参数传递进去\n"),e("code",[_._v("except Exception as <error>")])]),_._v(" "),e("li",[e("code",[_._v("else")]),_._v(" 子句包含没有抛出异常时执行的程序")]),_._v(" "),e("li",[e("code",[_._v("finally")]),_._v(" 子句包含无论是否抛出异常都执行的程序")]),_._v(" "),e("li",[_._v("传递异常：当方法执行出错时，会将异常传递给方法的调用者\n如果传递到主程序时仍然没有异常处理，程序才会终止\n在主程序中进行异常捕获有利于代码的复用")]),_._v(" "),e("li",[_._v("主动抛出异常\n"),e("ol",[e("li",[_._v("创建 "),e("code",[_._v("Excpetion")]),_._v(" 对象："),e("code",[_._v('Excpetion("出错信息")')])]),_._v(" "),e("li",[_._v("使用 "),e("code",[_._v("raise")]),_._v(" 关键字抛出异常，"),e("code",[_._v("raise Excpetion()")])])])]),_._v(" "),e("li",[e("code",[_._v("finally")]),_._v(" 的返回值会成为整个 "),e("code",[_._v("try")]),_._v(" 语句的返回值，无论是否有 "),e("code",[_._v("return")]),_._v(" 语句在 "),e("code",[_._v("try")]),_._v(" 或 "),e("code",[_._v("except")]),_._v(" 中。这包括在 "),e("code",[_._v("except")]),_._v(" 里抛出的异常。")])]),_._v(" "),e("h2",{attrs:{id:"文件处理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#文件处理"}},[_._v("#")]),_._v(" 文件处理")]),_._v(" "),e("ul",[e("li",[e("p",[e("code",[_._v("open")]),_._v(" 方法打开文件并返回文件操作对象\n第一个参数指定文件的路径\n第二个参数指定文件的打开方式")]),_._v(" "),e("ol",[e("li",[e("code",[_._v("r")]),_._v(" 只读方式")]),_._v(" "),e("li",[e("code",[_._v("w a")]),_._v(" 只写方式，指针在覆盖、末尾")]),_._v(" "),e("li",[e("code",[_._v("r+ a+ w+")]),_._v(" 读写方式，指针在开头、末尾、覆盖")]),_._v(" "),e("li",[_._v("读写方式打开文件会造成指针频繁移动，开发中尽量使用只读、只写方式")])])]),_._v(" "),e("li",[e("p",[e("code",[_._v("read")]),_._v(" 方法将文件读取到内存")])]),_._v(" "),e("li",[e("p",[e("code",[_._v("write")]),_._v(" 方法将内容写入文件")])]),_._v(" "),e("li",[e("p",[e("code",[_._v("close")]),_._v(" 方法关闭文件")])]),_._v(" "),e("li",[e("p",[e("code",[_._v("readlime")]),_._v(" 方法一次读取一行内容")])])])])}),[],!1,null,null,null);v.default=a.exports}}]);