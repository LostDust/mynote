(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{225:function(t,e,i){"use strict";i.r(e);var l=i(0),n=Object(l.a)({},(function(){var t=this,e=t.$createElement,i=t._self._c||e;return i("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[i("h1",{attrs:{id:"杂项"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#杂项"}},[t._v("#")]),t._v(" 杂项")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("SPA：single page web application（单页 Web 应用程序）")])]),t._v(" "),i("li",[i("p",[t._v("招聘：编程语言、数据结构与算法、计算机网络、操作系统、应用框架")])]),t._v(" "),i("li",[i("p",[t._v("前端工程化是什么？这是个很大的概念，但是在我们的日常开发中又很常见。当我们对一个工程进行设计并把它拆分成各个组件和模块时，我们是在做工程化；当我们用 Webpack 构建项目，配置好各个环境的打包配置时，我们是在做工程化；当我们为项目添加了 ESLint，并在每次提交之前自动检查代码质量时，我们是在做工程化。")])]),t._v(" "),i("li",[i("p",[t._v("处理依赖关系、预编译、模块处理、代码检查、代码压缩")])]),t._v(" "),i("li",[i("p",[t._v("纯函数定义：如果函数的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，必须只依赖于其输入参数。")])]),t._v(" "),i("li",[i("p",[t._v("fetch_IE：ie10，11使用 XMLHttpRequest，ie8，9 使用 XDomainRequest，ie8以下使用 ActiveXObject")])]),t._v(" "),i("li",[i("p",[t._v("Redux-thunk：在 Dispatch 一个 Action 之后，与到达 reducer 之前，进行一些额外的操作，就需要用到中间件，能够进行日志记录、创建崩溃报告，调用异步接口或者路由")])])])])}),[],!1,null,null,null);e.default=n.exports}}]);