# Python

[TOC]

## 变量与数据类型

- **Python 属于强 · 动态类型的语言**
- Number 数字类型
  Int 整数类型
  Float 浮点数类型
- Bool 布尔数类型
- String 字符串类型（字符串切片语法）
- List 列表：一组可重复元素组成的有序列表
  tuple(list) 方法将列表转换为元组
- Tuple 元组（相当于自读列表）
  list(typle) 方法将元组转换为列表
- Dictionary 字典：一组键值对组成的无序列表，其中键唯一

## 控制流

### 判断

- `if / else`
- `if / elif`
- 身份运算符
  使用 `is`、`not is` 来比较数据的内存地址是否一致

### 循环

- `while`
- `for / in` 遍历 list.value 或 map.key
- `while / else` 和 `for / else`

## 运算符

- 算数运算符
  幂运算：2\*\*2
- 赋值运算符
- 比较运算符
- 逻辑运算符

## 函数与模块与包管理

### 函数

- `def <Function>` 语句声明函数
- 缺省参数与不定参数
- 参数的扩展运算符
- 函数递归

### 模块

- `import <Modul>` 语句导入模块，可以通过 `<Modul>.<Function>` 的方式调用方法
- `import <Modul> as <ModulName>` 语句指定模块别名，应符合大驼峰命名法
- `from <Modul> import <Function>` 语句导入模块下对应的方法，不需要通过模块名就能调用
  这种导入方式可能会产生函数名冲突，后者会覆盖前者
- `from <Modul> import <Function> as <ModulName>` 语句为导入的方法指定别名
- `from <Modul> import *` 语句导入模块，并且不需要通过模块名就能调用方法
  这种方式同样可能产生函数名冲突

- Python 在导入模块时，会优先查询当前目录下的自定义模块，再搜索系统目录下的系统模块
  在开发时，应避免自定义模块与系统模块重名
- `__name__` 属性在程序执行时值为字符串 `__main__`，在被作为模块调用时值为模块名

### 包（package）

- 包是一个包含多个模块的特殊目录，包名带 `_` 后缀
- 目录里包含一个 `__init__.py` 文件，用于指定对外界提供的模块列表
  语法 `from . import <Modul>`
- 导入包可以一次性导入包里的所有模块
- 制作包
  1. 在包目录的上级目录中建立并配置 setup.py 文件
  2. 在终端执行 `python setup.py build` 命令构建模块
  3. 在终端执行 `python setup.py sdist` 命令生成压缩包
- 安装包
  1. 加压压缩包
  2. `python setup.py install` 命令安装包到 Python 的系统目录
- 卸载包
  `rm -r <package>*` 命令从 Python 的系统目录中删除包
- 包或模块的 `__file__` 属性记录了其路径
- 使用 pip 安装第三方模块
  `pip install <Modul>`
  `pip uninstall <Modul>`

## 面向对象（OOP）

### 封装

- **封装：将实现一类功能的属性与方法封装成一个抽象的类**
  对象可以将自身的属性和方法交给可信的类或对象操作，对不可信的隐藏
- **Python 通过 `class` 语句声明类，类名一般遵循大驼峰命名法**
- **再使用赋值语句将类实例化为对象**（不需要 `new` 语句）
- **在实例化对象的同时，会执行 `__init__` 方法来初始化对象**（构造函数）
- 在销毁一个对象时，会先执行一次对象的 `__del__` 方法（生命周期）
- 使用 `print` 方法打印一个对象时，默认输出这个对象归属的类和内存地址（0x）
  使用 `__str__` 方法可以自定义该对象的打印内容（需要 `return` 一个字符串）
- **在对象的属性名或方法名前加上 "\_\_" 前缀可以实现私有属性或私有方法**（伪）
  可以通过在属性名或方法名前面加上 `_<className>` 的方式访问私有属性或私有方法

### 继承（派生）

- **继承（extend）：在不需要重写类的情况下，对原本的功能进行扩展**
- 使用 `class Child(Parent):` 语法实现类的继承
  可以同时继承多个父类，实现多继承 `class Child(Parent1, Parent2...):`
- 子类无法继承父类的私有属性和私有方法，也不能调用父类的方法对子类的私有属性进行操作
- Python 中，以 `object` 类为基类的类为新式类，否则为旧式（经典）类；推荐使用新式类
  在 Python3 中如果没有指定父类，会默认使用 `object` 类作为父类

### 多态

- **多态：在继承链的不同层次名称相同但是功能不同的函数**
  本质是允许子类重写（override）或扩展父类定义的方法，实现接口重用
- **扩展父类方法：使用 `super().function()` 语法调用父类的方法**
  本质上是使用 `super` 对象调用父类的方法

### 类属性与类方法

- 声明类方法时需要在上面添加一行 `@classmathod` 修饰器来标识
- 类方法的第一个参数必须是 `cls`，而不是 `self`
- 封装类方式是为了便于访问类属性

### 静态方法

- 声明静态方法时需要在上面添加一行 `@staticmathod` 修饰器来标识
- 静态方法不需要 `self` 参数

## 设计模式

### 单例模式

- `__new__` 方法是由 `object` 基类提供的内置静态方法
  用于给对象分配内存空间，并返回对象的引用（self）
  注意：该方法时静态方法，调用时需要传入 `cls` 参数
- 重写 `__new__` 方法，在创建实例时检查是否已经存在实例
  如果存在：返回该实例
- 重写 `__init__` 方法，在初始化实例时检查是否需要初始化

## 异常处理

- 抛出（raise）异常
  在程序执行出现异常时会停止执行并抛出异常
- 捕获异常
  使用 `try - except` 语句可以将抛出的异常捕获，使程序得以继续执行
  `try` 下包含尝试执行的代码，`except` 下包含捕获到异常后执行的代码
  异常只会被离它最近的 `except` 捕获一次
- 根据错误类型捕获异常（有条件的 `except` 子句）
  `except <reason>:`
- 捕获未知错误，将异常信息作为参数传递进去
  `except Exception as <error>`
- `else` 子句包含没有抛出异常时执行的程序
- `finally` 子句包含无论是否抛出异常都执行的程序
- 传递异常：当方法执行出错时，会将异常传递给方法的调用者
  如果传递到主程序时仍然没有异常处理，程序才会终止
  在主程序中进行异常捕获有利于代码的复用
- 主动抛出异常
  1. 创建 `Excpetion` 对象：`Excpetion("出错信息")`
  2. 使用 `raise` 关键字抛出异常，`raise Excpetion()`
- `finally` 的返回值会成为整个 `try` 语句的返回值，无论是否有 `return` 语句在 `try` 或 `except` 中。这包括在 `except` 里抛出的异常。

## 文件处理

- `open` 方法打开文件并返回文件操作对象
  第一个参数指定文件的路径
  第二个参数指定文件的打开方式
  1. `r` 只读方式
  2. `w a` 只写方式，指针在覆盖、末尾
  3. `r+ a+ w+` 读写方式，指针在开头、末尾、覆盖
  4. 读写方式打开文件会造成指针频繁移动，开发中尽量使用只读、只写方式
- `read` 方法将文件读取到内存
- `write` 方法将内容写入文件
- `close` 方法关闭文件

- `readlime` 方法一次读取一行内容
